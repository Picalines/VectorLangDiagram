@using System.Reflection;
@using VectorLang.SyntaxTree;
@using VectorLang.Tokenization

<div>
    @if (SyntaxTree is null)
    {
        <span>@Name = null</span>
    }
    else
    {
        @if (IsPrivitive)
        {
            <span>@Name = @SyntaxTree</span>
        }
        else
        {
            <span style=@HeaderStyle @onclick="ToggleUnfolded">@Name (@TreeType.Name)</span>
        }

        @if (Unfolded)
        {
            if (SyntaxTree is IReadOnlyList<object> list)
            {
                @foreach (var element in list)
                {
                    <SyntaxTreeView SyntaxTree=element />
                }
            }
            else
            {
                @foreach (var prop in TreeProperties)
                {
                    <SyntaxTreeView Name=@prop.Name SyntaxTree=prop.GetValue(SyntaxTree) />
                }
            }
        }
    }
</div>

@code {
    [Parameter]
    public string? Name { get; set; }

    [Parameter]
    public object SyntaxTree { get; set; } = new Program(Array.Empty<Definition>());

    private Type TreeType => SyntaxTree.GetType();

    private readonly Type[] IgnoredPropertyTypes = new[] { typeof(Token), typeof(TextSelection) };

    private IEnumerable<PropertyInfo> TreeProperties => TreeType.GetProperties(BindingFlags.Instance | BindingFlags.Public)
        .Where(property => !IgnoredPropertyTypes.Any(property.PropertyType.IsAssignableTo));

    private bool IsPrivitive => SyntaxTree is string or int or double or Enum;

    private bool Unfolded = false;

    private string HeaderStyle => "cursor: pointer;" + (Unfolded ? "" : "font-weight: bold;");

    private void ToggleUnfolded()
    {
        Unfolded = !Unfolded;
    }
}
