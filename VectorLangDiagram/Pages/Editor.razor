@page "/editor"

@using System.Timers
@using VectorLang.Compilation
@using VectorLang.Diagnostics
@using VectorLang.Model
@using VectorLang.Tokenization

<EditorMenu OnViewSelected="windows => _ShownWindows = windows" />

<div id="sections">
    <section id="code-editor-section" style=@(_ShownWindows.HasFlag(EditorWindows.Code) ? "" : "display: none")>
        <CodeEditor @ref=_CodeEditor InitialValue=@ExampleProgram
            OnChange=OnCodeEdited
            CompletionProvider=ProvideCompletions />
    </section>
    <section style=@(_ShownWindows.HasFlag(EditorWindows.Diagram) ? "" : "display: none")>
        @if (_ExecutableProgram is not null)
        {
            <ExternalValuePanel ExternalValues=_ExecutableProgram.ExternalValues OnChange=ExecuteProgram />
        }
        <DiagramView Vectors=_PlottedVectors ErrorMessage=@_ErrorMessage />
    </section>
</div>

@code {
    private const string ExampleProgram = @"
// Velcome to VectorLang!

external aColor = RED;
external bColor = BLUE;

external useZoom = true;
external zoom = {1, 1};

external rotation = 0deg;

def sum(vector a, vector b) -> vector = a + b;

def main() -> void = [
    val a := {1, 0};
    val b := {0, 1};

    if (useZoom)
        scale(zoom);

    rotate(rotation);

    fill(aColor);
    plot(a);

    fill(bColor);
    plot(b);

    fill(aColor.blend(bColor, 0.5));
    plot(sum(a, b));
];
";

    private EditorWindows _ShownWindows = EditorWindows.Code | EditorWindows.Diagram;

    private readonly Timer _Timer = new(250);

    private CodeEditor _CodeEditor = null!;

    private Diagnoser? _Diagnoser = null;

    private ExecutableProgram? _ExecutableProgram = null;

    private Stack<PlottedVector> _PlottedVectors = new();

    private string? _ErrorMessage = null;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        _Timer.AutoReset = false;
        _Timer.Elapsed += async (_, _) => await InvokeAsync(OnTimerElapsed);

        _Timer.Start();
    }

    private void RenderVector(PlottedVector vector)
    {
        _PlottedVectors.Push(vector);
    }

    private async Task CompileProgram()
    {
        if (_ExecutableProgram is not null)
        {
            _ExecutableProgram.VectorPlotted -= RenderVector;
        }

        _ExecutableProgram = ProgramCompiler.Compile(_CodeEditor.Value, out _Diagnoser);

        foreach (var report in _Diagnoser.Reports)
        {
            await _CodeEditor.AddReportAsync(report);
        }

        int errorsCount = _Diagnoser.Reports.Count(report => report.Severity is ReportSeverity.Error);

        if (errorsCount > 0)
        {
            _ErrorMessage = $"{errorsCount} compilation errors";
        }

        if (_ExecutableProgram is not null)
        {
            _ExecutableProgram.VectorPlotted += RenderVector;
        }

        StateHasChanged();
    }

    private void ExecuteProgram()
    {
        if (_ExecutableProgram is null)
        {
            return;
        }

        _ErrorMessage = null;

        try
        {
            _PlottedVectors.Clear();
            _ExecutableProgram.Execute();
        }
        catch (RuntimeException runtimeException)
        {
            _ErrorMessage = runtimeException.Message;

            if (runtimeException.Selection is { } selection)
            {
                _ErrorMessage = $"{selection}: {_ErrorMessage}";
            }
        }

        StateHasChanged();
    }

    private IReadOnlyList<Completion> ProvideCompletions(TextLocation location)
    {
        if (_Diagnoser is not null)
        {
            return _Diagnoser.GetCompletions(location);
        }

        return Array.Empty<Completion>();
    }

    private async Task OnCodeEdited(string code)
    {
        await _CodeEditor.ClearReportsAsync();

        _ErrorMessage = null;

        _Timer.Stop();
        _Timer.Start();
    }

    private async Task OnTimerElapsed()
    {
        await CompileProgram();

        if (_ExecutableProgram is not null)
        {
            ExecuteProgram();
        }
    }
}
